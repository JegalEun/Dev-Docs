최근에 네트워크에 관심이 생겨 네트워크에 대해 앞으로 조금씩 정리해볼 예정이다.

# 흐름제어 (Flow control)
**흐름제어**란 송신측이 수신측의 처리속도보다 더 빨리 데이터를 보내지 못하도록 제어해주는 것을 의미힌다.

수신측이 송신측보다 속도가 빠른 것은 아무 문제가 되지 않지만 송신측이 수신측보다 속도가 빠르면 문제가 발생한다.

무슨 문제가 발생하냐?

수신측에서 수신된 데이터를 저장용량(queue)에 저장을 하고 처리해서 윗 계층으로 서비스를 하게 되는데,

만약에 송신측에서 보내는 데이터의 속도가 더 빠르다면 제한된 저장용량(queue)를 초과하여 이후에 도착하는 데이터의 손실을 가져올 수 있다.

이것을 `데이터 넘침`이라고 표현한다. 

그렇다면 송신과 수신측간에 불필요하게 응답과 재전송이 이루어지기때문에 효율이 떨어진다.

이러한 `데이터 넘침`이 일어나지 않기 위해 수신측에서 데이터를 그만 발송하라는 메세지를 송신측에 통보해야하는 피드백 매커니즘이 필요하다.

이를 `속도 조절`이라고 한다.
> 데이터를 수신하는 노드가 전송하는 노드에게 현재 자신의 상태에 대한 정보를 보내주는 것이다.

## 흐름제어 방식
위 문제를 해결하기 위해서는 두 가지 방법이 있다.

`stop and wait`과 `Sliding-Window` 방식이다.

### stop and wait
이 방법의 개념은 간단하다.

매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법이다.

1. Timeout을 설정한 후 Frame(data)을 전송하고
2. 이 시간(Timeout) 동안 수신 노드로부터 ACK이 도착하지 않으면 전송에 실패한 것으로 간주하고
3. 같은 Frame을 다시 전송하는 것이다.

다만, 이 방법은 다음과 같은 문제가 발생한다.

1. Frame이 손실되는 경우
2. ACK가 손실되는 경우
3. Timeout 기간이 너무 짧은 경우 => 수신 노드가 ACK을 보내도 이미 Timeout이 돼버려 송신 노드는 같은 Frame을 재전송

위와 같은 이유로 효율적이지 않지만 가장 큰 이유는 일정 시간 동안 한개의 Frame밖에 보내지 못한다.

그래서 이러한 효율성을 개선하고자 나온 방법이 `Sliding-Window`방식이다.

### Sliding-Window
이 방법은 수신 측에서 윈도우 사이즈를 설정하여 이 크기만큼 세그먼트를 전송하는 기법이다.
수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하여 제어하는 기법이다.

예를 한번 들어보겠다.

먼저, 송신자(A)와 수신자(B)는 각자 버퍼를 준비한다.

A는 자신의 버퍼에 데이터를 쓰고, B는 자신의 버퍼에서 데이터를 읽어오는 것이다. 

1. A가 B에게 100,000 byte의 파일을 전송하겠다!
2. 그러면 TCP가 이 파일을 100개의 패킷으로 나눈다(가정)
3. A와 B 사이에 연결이 된다.
4. B가 자신의 Receive Window Size를 A에게 알려준다.
5. A는 이 Size에 맞추어 B에게 데이터를 전송한다.

<img width="704" alt="윈도우 사이즈" src="https://user-images.githubusercontent.com/43868540/93662932-ced40680-fa9e-11ea-9d11-b0e0dce8bf14.png">

사진을 보면서 이해해보자.

송신자 A의 버퍼 상황이다.

A는 각 패킷에 번호를 매기고 패킷마다 Time을 건 다음 B에게 패킷을 전송한다.

위와 같은 상황에서 B가 3번 패킷을 받았다는 ack을 보내면 A는 8번 패킷을 전송한다.

이것처럼 윈도우에 포함되는 모든 패킷을 전송하고 패킷들의 전달이 확인 되는대로 윈도우를 옆으로 옮김(Slide)으로서 다음 패킷을 전송한다. 

1. 만약 B가 자신의 RWS가 3,000 bytes라고 하면 A는 30개의 패킷을 전송한다.
2. Time 안에 각 패킷에 대한 ack이 오지 않으면 ack을 받지 못한 패킷에 대해 재전송을 한다.
3. A는 자신이 전송한 가장 마지막 순서 패킷의 번호와 가장 최근에 받은 ack의 번호를 기억한다.

=> 위 그림의 경우 2번은 A가 가장 최근에 받은 ACK 패킷의 번호이고,
7번은 A가 전송한 패킷 중 가장 마지막 순서 패킷의 번호이다.

B의 데이터를 읽는 속도가 떨어질 경우, WS(Window Size)를 줄여가며 송신자의 데이터 전송을 컨트롤할 수 있다.

또한 수신 쪽의 확인(응답)을 받지 않고도 윈도우 크기만큼 데이터를 보내는 것이 가능하므로 `stop-and-wait`보다 네트워크를 효율적으로 사용할 수 있다.

이번 시간에는 `호스트`와 `호스트` 간의 데이터 처리를 효율적으로 하는 `Flow Control`에 대해 알아봤다면

다음 시간에는 `호스트`와 `네트워크` 상의 데이터 처리를 효율적으로 하는 `Congestion control`에 대해 알아볼 것이다.

----
#### Referece
- [Flow control](https://velog.io/@directorhwan59/TCP-IP-흐름제어-flow-control)
