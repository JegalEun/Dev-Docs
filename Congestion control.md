# congestion control(혼잡 제어)

저번 시간에는 송신 측과 수신 측의 데이터 처리 속도를 해결하기 위해 쓰이는 `flow control`에 대해 배우는 시간을 가졌다.

이번 시간에는 `congesion control`에 대해 배우는 시간을 가질 예정이다.

`congesion control`이란 송신 측의 데이터 전달과 네트워크의 **데이터 처리 속도 차이**를 해결하기 위한 기법이다. 

송신 측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다.

이러한 네트워크 상의 라우터가 항상 한가로운 것은 아니기 때문에 데이터가 급격히 몰릴 경우 문제가 발생한다.

만약, 한 라우터에 데이터가 몰릴 경우(=혼잡할 경우) 라우터는 자신에게 온 데이터를 모두 처리할 수 없다.

그렇다면 송신 측에서 데이터를 다시 재전송을 하게 되고 혼잡을 가중시켜 오버플로우가 발생해 데이터 손실을 야기시킨다.

따라서, 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 강제로 줄이게 것을 혼잡제어라 한다.

송신 측과 수신 측 사이의 전송속도를 다루는 데에 반해 혼잡제어는 호스트와 라우터를 포함한 보다 넓은 관점에서의 전송 문제를 다루게된다.

혼잡 제어 알고리즘에는 네 가지가 있다.

1. AIMD (Additive/Multicative Decrease)
2. Slow start (느린 시작)
3. 혼잡 회피
4. Fast Recovery (빠른 회복)

하나씩 살펴보기 전에 `MSS`에 대해 알고 넘어가야한다.

## 혼잡 윈도우 크기 초기화 하기
통신을 하는 중간에는 ACK가 유실된다거나 타임아웃이 난다거나 하는 등의 정보를 사용하여 네트워크의 혼잡 상황을 유추할 수 있지만, 
통신을 시작하기 전에는 그런 정보가 하나도 없기 때문에 혼잡 윈도우의 크기를 정하기가 조금 애매하다. 여기서 등장하는 것이 바로 `MSS(Maximum Segment Size)`이다. 

`MSS`는 한 세그먼트에 최대로 보낼 수 있는 데이터의 양을 나타내는 값인데, 대략 다음과 같은 계산을 통해 구할 수 있다.
> MSS = MTU - (IP헤더길이+IP옵션길이) - (TCP헤더길이+TCP옵션길이)

여기서 `MTU(Maximum Transmission Unit)` **한번 통신 때 보낼 수 있는 최대 단위를 의미한다.**

즉, `MSS`는 한번 전송할 때 보낼 수 있는 최대 단위가 정해져 있는 상황에서 IP 헤더, TCP 헤더 등 데이터가 아닌 부분을 전부 발라내고 **데이터를 담을 수 있는 공간**얼마나 남았는 지를 나타내는 것이다.

![MTU](https://user-images.githubusercontent.com/43868540/95658420-2ffa7180-0b55-11eb-8913-594d8438ac87.PNG)
> 우리집 컴퓨터의 MTU값.

MTU 기본값으로 `1500 bytes`가 설정되어 있는 것을 확인 할 수 있다. OSX는 기본적으로 `MTU`를 `1500 bytes`로 설정한다.

이때 TCP와 IP의 헤더크기가 각각 `20bytes`라고 하면 MSS는 `1500-40=1460bytes`가 되는 것이다.

## AIMD
`AIMD (Additive/Multicative Decrease)` 방식은 우리 말로 직역하면 **합 증가/곱 감소 방식**이라는 뜻이다.

즉, 네트워크에 아직 별 문제가 없어서 전송 속도를 더 빠르게 하고 싶다면 혼잡 윈도우 크기를 **1씩 증가**시키지만, 중간에 데이터가 유실되거나 응답이 오지 않는 등의 혼잡 삳태가 감지되면 혼잡윈도우 크기를 **반**으로 줄인다.

늘어날 때는 `ws+1`, 줄어들 때는 `ws*0.5`이다.

이렇게 늘어날 때는 선형적으로 조금씩 늘어나고 줄어들 때는 반으로 확 줄어드는 AIMD 방식의 특성때문에 혼잡 윈도우 크기를 그래프로 그려보면 다음과 같은 톱니 모양이 나타난다.

<img width="608" alt="AIMD" src="https://user-images.githubusercontent.com/43868540/94355427-eb83c600-00be-11eb-83aa-cf7377e5df8c.png">

- [출처 evan-moon.github](https://evan-moon.github.io/2019/11/26/tcp-congestion-control/)

그러나 AIMD의 문제점은 네트워크 대역이 많이 남아도는 상황에도 윈도우 크기를 너무 조금씩 늘리면서 접근한다는 것이다.

그런 이유로 AIMD방식은 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 조금 걸린다. 

## Slow Start
위에서 이야기했듯이 `AIMD`방식은 윈도우 크기를 선형적으로 증가시키기 때문에 제대로 된 속도가 나오기까지 시간이 조금 걸리는 단점이 있다.

요즘 네트워크는 대역폭이 워낙 넓고 인프라도 좋기때문에 네트워크의 혼잡 상황 발생하는 빈도가 많이 줄어들었기 때문에, 혼잡이 발생하지도 않았는데 제대로 속도를 내는데까지 오래걸리는 `AIMD` 방식의 단점이 점점 부각되었따.

반면, `Slow Start`는 기본적인 원리는 `AIMD`와 비슷하지만 윈도우 크기를 증가시킬 때는 지수적으로 증가시키다가 손실 이벤트(혼잡)가 있을 경우에 윈도우 크기를 `1`로 줄여버리는 방식이다.

이 방식은 보낸 데이터의 ACK가 도착할 때마다 윈도우 크기를 증가시키기 때문에 처음에는 윈도우 크기가 조금 느리게 증가할지 몰라도, 시간이 가면 갈수록 윈도우 크기가 점점 빠르게 증가한다는 장점이 있다.

![slow start](https://user-images.githubusercontent.com/43868540/95658695-502b3000-0b57-11eb-9ebc-5a05d5d725ba.PNG)
> [출처 evan-moon.github](https://evan-moon.github.io/2019/11/26/tcp-congestion-control/)

slow start의 차트를 확인해보면 `AIMD`보다는 급격하게 윈도우 크기가 커지는 것을 확인할 수 있다. 

### Slow start 임계점(ssthresh)
`ssthresh`는 쉽게 말하면 `여기까지만 Slow Start를 사용하겠다.`라는 의미를 가진다. 

![ssthresh](https://user-images.githubusercontent.com/43868540/95659718-ec583580-0b5d-11eb-9a11-6fd269d690c4.PNG)
> [출처 evan-moon.github](https://evan-moon.github.io/2019/11/26/tcp-congestion-control/)

이 값을 사용하는 이유는 Slow Start를 사용하며 윈도우 크기를 지수적으로 증가시키다보면 어느 순간부터 윈도우 크기가 기하급수적으로 늘어나서 제어가 힘들어지기도 하고, 네트워크의 혼잡이 예상되는 상황에서는 빠르게 값을 증가시키는 것보다 조금씩 증가시키는 편이 훨씬 안전하기 때문이다.

쉽게 생각해서 현재 윈도우 크기가 10이고 현재 네트워크에 남은 공간이 15라고 할 때, Slow Start 방식으로 윈도우 크기를 증가시키면 20을 넘겨버리지만 합 증가를 하게 되면 앞으로 한 5번은 윈도우 크기를 더 증가시킬 수 있다.

그래서 특정한 임계점(Threshold)를 정해놓고, 임계점을 넘어가게되면 AIMD 방식을 사용하여 선형적으로 윈도우 크기를 증가시킨다. 그래서 이 임계점을 칭하는 단어가 ssthresh(Slow Start Threshold)인 것이다.

송신 측은 본격적인 통신이 시작하기 전에 ssthresh 값을 자신의 혼잡 윈도우의 절반 크기인 0.5 MSS으로 초기화하고, 이후 어떤 혼잡 제어 방법을 사용하냐에 따라 다르게 대처하게된다.

## Fast Transmit
빠른 재전송은 TCP의 혼잡 조절에 추가된 정책이다. 패킷을 받는 쪽에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다. 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로 주간에 패킷 하나가 손실되게 되면 보내는 측에서는 순번이 중복된 ACK 패킷을 받게 되고, 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송할 수 있다.

빠른 재전송은 중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다. 이런 현상이 일어나는 것은 약간 혼잡한 상황이 일어난 것으로 혼잡을 감지하고 `Window size`를 줄이게 된다.

## Fast Recovery
빠른 회복 정책은 혼잡한 상태가 되면 Slow start처럼 `Window size`를 `1`로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다.

빠른 회복은 크게 2가지로 나뉜다.

1. TCP Tahoe
`TCP Tahoe`는 `Slow Star`t를 사용한 혼잡 제어 정책의 초기 버전으로, `빠른 재전송` 기법이 처음으로 도입된 방법이다.

`Tahoe`는 처음에는 `Slow Start`를 사용하여 자신의 윈도우 크기를 지수적으로 빠르게 증가시키다가 `ssthresh`를 만난 이후부터는 `AIMD`에서 사용하는 합 증가 방식을 사용하여 선형적으로 윈도우 크기를 증가시킨다.

그러다가 `ACK Duplicated`나 `Timeout` 즉, 손실이벤트가 발생하면 네트워크에 혼잡이 발생했다고 판단하고, `ssthresh`와 자신의 윈도우 크기를 수정하게 된다. 

타임아웃이 되거나 3개의 중복 ACK에 의한 손실이 발생하면 무조건 혼잡윈도우를 1MSS로 줄이고, 슬로 스타트 단계로 들어간다.

2. TCP Reno
Tahoe 이후에 나온 버전으로 3개의 중복 ACK에 의한 손실이 발생하면 혼잡윈도우 크기를 1MSS로 줄이는게 아니라 현재 혼잡윈도우 크기의 절반으로 줄인다음 1MSS씩 선형으로 증가를 시킨다. 만약 타임아웃에 의한 손실이라면 Tahoe와 마찬가지로 1MSS로 초기화 되고 슬로스타트를 진행한다.

![congestion control](https://user-images.githubusercontent.com/43868540/95659402-ba45d400-0b5b-11eb-8561-5ee1718ec8f1.PNG)
 > 출처 [blog.naver](http://blog.naver.com/PostView.nhn?blogId=sjc02183&logNo=221686794605&parentCategoryNo=&categoryNo=55&viewDate=&isShowPopularPosts=false&from=postView)
 
위 그림을 보면 9라운드부터 타호와 리노의 모양이 달라지는 것을 확인할 수 있다. 

----
#### Reference
- [TCP의 혼잡제어](https://evan-moon.github.io/2019/11/26/tcp-congestion-control/)
