# congestion control(혼잡 제어)

저번 시간에는 송신 측과 수신 측의 데이터 처리 속도를 해결하기 위해 쓰이는 `flow control`에 대해 배우는 시간을 가졌다.

이번 시간에는 데이터와 네트워크의 데이터 처리 속도 차이를 해결하기 위해 쓰이는 `congesion control`에 대해 배우는 시간을 가질 예정이다.

송신 측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법이다. 

송신 측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다.

하지만 이러한 네트워크 상의 라우터가 항상 한가로운 것은 아니기 때문에 데이터가 급격히 몰릴 경우 문제가 발생한다.

만약, 한 라우터에 데이터가 몰릴 경우(=혼잡할 경우) 라우터는 자신에게 온 데이터를 모두 처리할 수 없다.

그렇다면 송신 측에서 데이터를 다시 재전송을 하게 되고 혼잡을 가중시켜 오버플로우가 발생해 데이터 손실을 야기시킨다.

따라서, 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 강제로 줄이게 된다.

혼잡 제어 알고리즘에는 네 가지가 있다.

1. AIMD (Additive/Multicative Decrease)
2. Slow start (느린 시작)
3. Fast Retransimit (빠른 재전송)
4. Fast Recovery (빠른 회복)

하나씩 살펴보기 전에 `MSS`에 대해 알고 넘어가야한다.

## 혼잡 윈도우 크기 초기화 하기
통신을 하는 중간에는 ACK가 유실된다거나 타임아웃이 난다거나 하는 등의 정보를 사용하여 네트워크의 혼잡 상황을 유추할 수 있지만, 
통신을 시작하기 전에는 그런 정보가 하나도 없기 때문에 혼잡 윈도우의 크기를 정하기가 조금 애매하다. 여기서 등장하는 것이 바로 `MSS(Maximum Segment Size)`이다. 

`MSS`는 한 세그먼트에 최대로 보낼 수 있는 데이터의 양을 나타내는 값인데, 대략 다음과 같은 계산을 통해 구할 수 있다.
> MSS = MTU - (IP헤더길이+IP옵션길이) - (TCP헤더길이+TCP옵션길이)

여기서 `MTU(Maximum Transmission Unit)는 **한번 통신 때 보낼 수 있는 최대 단위를 의미한다.**

즉, `MSS`는 한번 전송할 때 보낼 수 있는 최대 단위가 정해져 있는 상황에서 IP 헤더, TCP 헤더 등 데이터가 아닌 부분을 전부 발라내고 진짜 데이터를 담을 수 있는 공간이 얼마나 남았는 지를 나타내는 것이다.

## AIMD
`AIMD (Additive/Multicative Decrease)` 방식은 우리 말로 직역하면 **합 증가/곱 감소 방식**이라는 뜻이다.

즉, 네트워크에 아직 별 문제가 없어서 전송 속도를 더 빠르게 하고 싶다면 혼잡 윈도우 크기를 **1씩 증가**시키지만, 중간에 데이터가 유실되거나 응답이 오지 않는 등의 혼잡 삳태가 감지되면 혼잡윈도우 크기를 **반**으로 줄인다.

늘어날 때는 `ws+1`, 줄어들 때는 `ws*0.5`이다.

이렇게 늘어날 때는 선형적으로 조금씩 늘어나고 줄어들 때는 반으로 확 줄어드는 AIMD 방식의 특성때문에 혼잡 윈도우 크기를 그래프로 그려보면 다음과 같은 톱니 모양이 나타난다.

<img width="608" alt="AIMD" src="https://user-images.githubusercontent.com/43868540/94355427-eb83c600-00be-11eb-83aa-cf7377e5df8c.png">

- [출처 evan-moon.github](https://evan-moon.github.io/2019/11/26/tcp-congestion-control/)

