# 인접행렬과 인접리스트
그래프를 구현하는 방법에는 `배열(Array)`을 사용하는 방법과 `연결리스트(Linked List)`를 사용하는 방법이 있다.

##  인접 행렬
인접 행렬이란 그래프의 연결 관계를 **이차원배열**로 표현한다. 보통 map[][] 형태로 많이 사용한다.
> map[i][j] : i에서 j로 가는 간선이 있다면 1, 없다면 0

<img width="616" alt="인접 행렬 방향 그래프" src="https://user-images.githubusercontent.com/43868540/149541878-4b90b8a0-ea6d-45a0-ad60-1ef03379db46.png">

> [출처](https://seohyun0120.tistory.com/entry/C-BFS와-DFS-인접행렬과-인접리스트)

위의 그래프는 방향 그래프를 행렬로 표현하였다. 그렇다면 무방향 그래프라면 행렬이 어떻게 변할까?

<img width="616" alt="인접 행렬 무방향 그래프" src="https://user-images.githubusercontent.com/43868540/149542173-799a69df-d09c-48c9-aa87-a1cfe2b8d165.png">

> [출처](https://seohyun0120.tistory.com/entry/C-BFS와-DFS-인접행렬과-인접리스트)

무방향 그래프는 대각선을 기준으로 대칭인 성질을 가지게 된다. (두 개의 정점에서 간선이 동시에 연결되어 있기 때문이다.)

## 인접 행렬을 사용하는 이유

## 장점
- 구현이 빠르다.
- 노드가 서로 연결되어있는지 확인하기 쉽다. `O(1)`의 시간복잡도를 가진다.

## 단점
v : 정점, E : 간선
- 정점의 개수가 N인 그래프를 행렬로 표현하면 `V*V개`의 메모리 공간이 필요하며, 메모리 낭비가 생긴다.
- 특정 노드에 연결된 모든 노드를 검색할 때 map[i][1]~map[i][V]를 전부 확인해야한다.
- 전체 노드 탐색 시 `O(V*V)`의 시간복잡도를 가진다..

## 인접 리스트
인접 리스트란 그래프의 연결 관계를 **연결리스트**로 표현한다.

<img width="866" alt="인접 리스트" src="https://user-images.githubusercontent.com/43868540/149543028-945eef03-4eeb-4dd9-8c3f-1f964dd3e973.png">

> [출처](https://seohyun0120.tistory.com/entry/C-BFS와-DFS-인접행렬과-인접리스트)

즉, 정점의 개수만큼 인접리스트가 존재하며, 각각의 인접리스트에는 인접한 정점 정보가 저장되는 것이다. 그래프는 각 인접리스트에 대한 헤드포인터를 배열로 갖는다.

무방향 그래프의 경우, 간선이 추가되면 각각의 정점의 인접리스트에 반대편 정점의 노드를 추가해야 한다.

## 장점
v : 정점, E : 간선
- 실제 연결된 노드만 저장하기때문에 메모리 측면에서 이득이다.
> 인접 리스트+에지를 저장하는 것 `O(V+E)`만큼의 메모리 필요
- 모든 원소의 개수 합 = 간선의 개수
- 전체 노드 탐색 시 `O(E)`의 시간복잡도를 가진다.

## 단점
- 노드가 서로 연결되어 있는지 확인하는데 오래 걸린다. `O(degree(v))`의 시간복잡도를 가진다.
> 인접 행렬인 경우 map[i][j]가 1인지만 확인하면 되지만 인접 리스트의 경우 탐색해야 하므로 정점의 차수만큼의 시간이 필요하다. 
- 구현이 비교적 어렵다.

## 인접 행렬과 인접 리스트의 시간 복잡도
상황에 따라 시간복잡도를 고려해서 인접 행렬과 인접 리스트 중 걸맞는 방법을 선택해서 사용해야한다.

시간 복잡도는 크게 두 가지로 나눈다.

- 두 노드가 연결되어 있는지 확인하는데 걸리는 시간
- 한 노드에 연결된 모든 노드들을 확인하는데 걸리는 시간

### 두 노드가 연결되어 있는지 확인하는데 걸리는 시간 

**인접 행렬**은 행렬에 접근하여 `O(1)`로 바로 알 수 있다.

**인접 리스트**는 리스트 안에 데이터를 모두 돌아야 한다. `O(V)`

### 한 노드에 연결된 모든 노드들을 확인하는데 걸리는 시간

**인접 행렬**은 행렬 전체를 다 돌아야하므로 `O(v)`

**인접 리스트**는 자신과 인접한 노드들에 대한 레퍼런스를 가지고 있기 때문에 노드에 연결된 엣지의 개수만 확인하면 된다. 따라서 `O(E)`

간선의 수가 많으면 인접행렬이 유리하고 간선의 수가 적으면 인접리스트가 효율적이다.

----
#### Reference
- [인접행렬 vs 인접리스트](https://suyeon96.tistory.com/32)
- [BFS, DFS](https://seohyun0120.tistory.com/entry/C-BFS와-DFS-인접행렬과-인접리스트)
- [시간 복잡도](https://codermun-log.tistory.com/288)


